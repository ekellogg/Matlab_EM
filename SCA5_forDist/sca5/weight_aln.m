function [wX,W] = weight_aln(X3d,varargin)
% usage: [wX,W]=weight_aln(x3d); 

% This function taken in the binary tensor representation of a multiple
% sequnece alignment (x3d, generated by binrep.m), and outputs the weighted
% alignment tensor (wX) and the weight matrix (W).  By default, the
% weighting function is the gradient of relative entropy, derived from the
% idea that weight for each position i in each sequence n should be related
% to the perturbation in the conservation of position i by removing
% sequence n (see Note xx). Conservation in SCA is computed by the
% Kullback-Leibler relative entropy, and it is straightforward to show that
% the perturabtion in conservation is proportional to the gradient of
% relative entropy.

% Optional input arguments are a function handle to an alternate weighting
% function and a single parameter that can be passed to the weighting
% function; usage of these alternate functions implies a different
% conceptual principle for computing conservation of sites, and might be
% considered as we better understand the generative process in evolution
% that produces the observed statistics at sites.  If used, an alternate
% weighting function should have the following form: F(f,q,a), where f
% represents frequencies of amino acids at sites, q represents the
% reference frequency for amino acids, and a is an optimal single
% parameter.

% This function is called in sca5.m

% ***********************
% Authors: Rama Ranganathan (rama.ranganathan@UTSouthwestern.edu)
%          Olivier Rivoire (olivier.rivoire@ujf-grenoble.fr)
% 8/2011
%
% Copyright R.Ranganathan 1999-2011
%**************************************************************************

% default parameters...the weights are gradient of Kullback-Leibler
% entropy, computed in DerivEntropy.m

weights=@DerivEntropy;
para=[];

% Treatment of optional arguments:
if nargin>1
    for i=2:nargin
        if isa(varargin{i-1},'function_handle'); weights=varargin{i-1};end
        if isa(varargin{i-1},'char'); 
            if strcmp(varargin{i-1},'nv')
                nv_flag=1;
            else
                disp('Option unrecognized...ignoring');
            end
        end
        if isa(varargin{i-1},'numeric'); 
            if strcmp(func2str(weights), 'DerivEntropy')
                disp('No parameters allowed for DerivEntropy weighting function..ignoring para');
            else
                para=varargin{i-1};
            end
        end
    end
end


% Constants....the background frequencies for amino acids
prob_ref=[.073 .025 .050 .061 .042 .072 .023 .053 .064 .089 .023 .043 .052 .040 .052 .073 .056 .063 .013 .033]; 

% MAIN PROGRAM
% *****************************************************************

% Convert the 3D binary tensor version of the MSA into a matrix
% representation for computational simplicity
[N_seq,N_pos,N_aa]=size(X3d);
X3d_mat=zeros(N_seq,N_aa*N_pos);
X3d_mat=reshape(permute(X3d,[3,2,1]),N_aa*N_pos,N_seq);

% Now we get frequencies and compute the weights given the reference
% frequencies of amino acids, a weight function, and an optional parameter
f1_vect=sum(X3d_mat')/N_seq;
W_vect=ones(1,N_aa*N_pos);
q1_vect=repmat(prob_ref,1,N_pos);
if isempty(para)
    for x=1:N_aa*N_pos, W_vect(x)=feval(weights,f1_vect(x),q1_vect(x)); end
else
    for x=1:N_aa*N_pos, W_vect(x)=feval(weights,f1_vect(x),q1_vect(x),para); end
end
W=zeros(N_pos,N_aa);
for i=1:N_pos
    for a=1:N_aa
        W(i,a)=W_vect(N_aa*(i-1)+a);
    end
end

% scale the weights by 1/N_seqs; this scaling emerges in the perturbative
% expansion of the K-L relative entropy (see Note xx), but is unnecessary
% and is not used here.

% W=(1/N_seq).*W;

% We then calculate the weighted 3D alignment tensor (wX)
 wX=zeros(N_seq,N_pos*N_aa);
 wX=repmat(reshape(W,[1 N_pos N_aa]),[N_seq 1 1]).*X3d;

end

